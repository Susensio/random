from time import time


def p41():
    """ Pandigital prime
    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n
    exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
    What is the largest n-digit pandigital prime that exists?
    """
    import sys
    sys.path.append("../idea bag/")
    from prime_factors import is_prime
    from itertools import permutations

    # EVERY 9 and 8 digit pandigital number is divisible by 3 as the sum of its digits is 45 and 36
    # Thus the search starts with 7 digits
    result = 0
    # Generate all posible permutations of [1..n] for n in [7..1]
    for digits in range(7, 1, -1):
        perms = permutations(str(d) for d in range(1, digits + 1))
        # Reverse sort perms and check for primes
        for perm in sorted(perms, reverse=True):
            if is_prime(int(''.join(perm))):
                result = int(''.join(perm))
                break
        else:
            continue  # executed if the loop ended normally (no break)
        break  # executed if 'continue' was skipped (break)

    return "Largest pandigital prime: {}".format(result)


def p42():
    """ Coded triangle numbers
    The nth term of the sequence of triangle numbers is given by, tn = 0.5n(n+1); so the first ten
    triangle numbers are:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    By converting each letter in a word to a number corresponding to its alphabetical position and
    adding these values we form a word value. For example, the word value for SKY is
    19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word
    a triangle word.
    Using words.txt, a 16K text file containing nearly two-thousand common English words, how many
    are triangle words?
    """
    import csv

    def letter_to_num(letter):
        return ord(letter.upper()) - 64  # 64 = ord('A') - 1

    triangular_nums = {n * (n + 1) // 2 for n in range(50)}

    def is_triangular(word):
        value = sum(letter_to_num(letter) for letter in word)
        return value in triangular_nums

    with open('words.txt') as file:
        reader = csv.reader(file, delimiter=',')
        words = list(reader)[0]

    return "Triangular words: {}".format(len([word for word in words if is_triangular(word)]))


def p43():
    """ Sub-string divisibility
    The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the
    digits to 9 in some order, but it also has a rather interesting substring divisibility property.

    Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:

    d2d3d4=406 is divisible by 2
    d3d4d5=063 is divisible by 3
    d4d5d6=635 is divisible by 5
    d5d6d7=357 is divisible by 7
    d6d7d8=572 is divisible by 11
    d7d8d9=728 is divisible by 13
    d8d9d10=289 is divisible by 17

    Find the sum of all 0 to 9 pandigital numbers with this property.
    """
    from itertools import permutations

    primes = (2, 3, 5, 7, 11, 13, 17)
    # Reduce number of possibilities by x10
    pandigitals = [perm for perm in permutations('0123456789')
                   if perm[3] in {'0', '2', '4', '6', '8'}  # % 2 == 0
                   and perm[5] in {'0', '5'}]  # % 5 == 0

    print(len(pandigitals))

    def has_property(num_list):
        return all(int(num_list[i + 1:i + 4]) % primes[i] == 0
                   for i in range(7)
                   if primes[i] not in {2, 5})

    results = [pan for pan in pandigitals if has_property(''.join(pan))]
    return sum(int(''.join(pan)) for pan in results)


def p44():
    """ Pentagon numbers
    Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal
    numbers are:
    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
    It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48,
    is not pentagonal.

    Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are
    pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
    """

    def pentagonal_number(n):
        return n * (3 * n - 1) // 2

    n = 1

    pentagonals = set()
    while True:
        # P = Pj + Pk
        P = pentagonal_number(n)

        for Pk in pentagonals:
            Pj = P - Pk
            if Pj in pentagonals:
                difference = Pk - Pj
                if difference in pentagonals:
                    return difference

        pentagonals.add(P)

        n += 1


def p45():
    """ Triangular, pentagonal, and hexagonal
    Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

    Triangle        Tn=n(n+1)/2         1, 3, 6, 10, 15, ...
    Pentagonal      Pn=n(3n−1)/2        1, 5, 12, 22, 35, ...
    Hexagonal       Hn=n(2n−1)          1, 6, 15, 28, 45, ...

    It can be verified that T285 = P165 = H143 = 40755.

    Find the next triangle number that is also pentagonal and hexagonal.
    """
    def triangle(n):
        return n * (n + 1) // 2

    def pentagonal(n):
        return n * (3 * n - 1) // 2

    def hexagonal(n):
        return n * (2 * n - 1)

    seeds = [1, 1, 1]
    formulae = [triangle, pentagonal, hexagonal]
    polygonals = [1, 1, 1]

    results = []

    while len(results) < 3:
        if polygonals[0] == polygonals[1] == polygonals[2]:
            results.append((tuple(seeds), polygonals[0]))

        i = polygonals.index(min(polygonals))
        seeds[i] += 1
        polygonals[i] = formulae[i](seeds[i])

    return results


def p46():
    """ Goldbach's other conjecture
    It was proposed by Christian Goldbach that every odd composite number can be written
    as the sum of a prime and twice a square.

    9 = 7 + 2×1²
    15 = 7 + 2×2²
    21 = 3 + 2×3²
    25 = 7 + 2×3²
    27 = 19 + 2×2²
    33 = 31 + 2×1²

    It turns out that the conjecture was false.

    What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
    """
    import sys
    sys.path.append("../idea bag/")
    from prime_factors import is_prime
    from next_prime import next_prime
    from itertools import islice

    def odd_composite_generator():
        """ Odd non-prime number."""
        n = 1
        while True:
            n += 2
            if not is_prime(n):
                yield n

    odd_composite = odd_composite_generator()

    primes = [2]

    def primes_upto_atleast(number):
        """ Generate primes on demand."""
        while True:
            np = next_prime(primes[-1])
            if number < np:
                break
            primes.append(np)
        return primes

    def is_valid(number):
        for prime in primes_upto_atleast(number):
            rest = number - prime
            base = (rest / 2) ** 0.5
            if base == int(base):
                return True

    for number in odd_composite:
        if not is_valid(number):
            return number


def p47():
    """ Distinct primes factors
    The first two consecutive numbers to have two distinct prime factors are:

    14 = 2 × 7
    15 = 3 × 5

    The first three consecutive numbers to have three distinct prime factors are:

    644 = 2² × 7 × 23
    645 = 3 × 5 × 43
    646 = 2 × 17 × 19.

    Find the first four consecutive integers to have four distinct prime factors each.
    What is the first of these numbers?
    """
    import sys
    sys.path.append("../idea bag/")
    from prime_factors import sieve_of_eratosthenes, factors as factorize
    from next_prime import next_prime
    from functools import lru_cache

    primes = set(sieve_of_eratosthenes(100000))
    biggest = max(primes)

    def primes_upto_atleast(number):
        """ Generate primes on demand."""
        nonlocal biggest
        while True:
            if number < biggest:
                break
            np = next_prime(biggest)
            primes.add(np)
            biggest = np
        return primes

    @lru_cache(maxsize=4)
    def prime_factors(number):
        return [n for n in factorize(number) if n in primes_upto_atleast(number // 2)]

    num = 1000 - 4
    while True:
        factors = [len(prime_factors(num + i)) == 4 for i in range(4)]
        if all(factors):
            return num
        num += 4 - factors[::-1].index(False)


def p48():
    """ Self powers
    The series, 1¹ + 2² + 3³ + ... + 10¹⁰ = 10405071317.

    Find the last ten digits of the series, 1¹ + 2² + 3³ + ... + 1000¹⁰⁰⁰.
    """
    def last_ten_digits(number):
        return number % 10000000000

    accumulator = 0
    for i in range(1, 1 + 1000):
        summand = 1
        for _ in range(i):
            summand = last_ten_digits(summand * i)
        accumulator = last_ten_digits(accumulator + summand)
    return accumulator


def p49():
    """ Prime permutations
    The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330,
    is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit
    numbers are permutations of one another.

    There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting
    this property, but there is one other 4-digit increasing sequence.

    What 12-digit number do you form by concatenating the three terms in this sequence?
    """
    pass


if __name__ == '__main__':

    # functions = (p41, p42, p43, p44, p45, p46, p47, p48, p49, p50)

    # for func in functions:
    #     ts = time()
    #     print(func())
    #     te = time()
    #     print("{}(): {} s\n".format(func.__name__, (te - ts)))
    func = p48

    ts = time()
    print(func())
    # [func() for _ in range(1000)]
    te = time()
    print("{}(): {} s\n".format(func.__name__, (te - ts)))
