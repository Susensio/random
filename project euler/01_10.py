from math import sqrt
from time import time


def p1():
    """ Multiples of 3 and 5
    If we list all the natural numbers below 10 that are multiples of 3 or 5,
    we get 3, 5, 6 and 9. The sum of these multiples is 23.
    Find the sum of all the multiples of 3 or 5 below 1000.
    """
    return sum([n for n in range(1000) if n and (n % 3 == 0 or n % 5 == 0)])


def p2():
    """ Even Fibonacci numbers
    Each new term in the Fibonacci sequence is generated by adding the previous two terms.
    By starting with 1 and 2, the first 10 terms will be:
    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million,
    find the sum of the even-valued terms.
    """
    fibonacci = []
    a = b = 1
    while a < 4000000:
        fibonacci.append(a)
        a, b = b, a + b
    return sum([n for n in fibonacci if n % 2])


def p3():
    """ Largest prime factor
    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143 ?
    """
    number = 600851475143
    for n in range(2, 600851475143 // 2):
        while number % n == 0:
            number = number // n
            if not [n for n in range(2, int(sqrt(number))) if number % n == 0]:
                return number


def p4():
    """ Largest palindrome product
    A palindromic number reads the same both ways. The largest palindrome made
    from the product of two 2-digit numbers is 9009 = 91 × 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    """
    def is_palindromic(num):
        number = str(num)
        index = 0
        while index < len(number)//2:
            if not number[index] == number[-1 - index]:
                # Break the loop as soon as not equality is found
                return False
            index += 1
        return True
        # return all([number[index] == number[-1 - index] for index in range(0, len(number) // 2)])

    palindromes = [x * y for x in range(100, 1000)
                   for y in range(100, 1000)
                   if x >= y and is_palindromic(x * y)]

    return sorted(palindromes, reverse=True)[0]


def p5():
    """ Smallest multiple
    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    """
    factors = range(2, 21)
    # number = 20 * 19
    # while True:
    #     if all([not number % factor for factor in factors]):
    #         return number
    #     number += 20
    # VERY SLOW (15s) different approach is possible

    from functools import reduce

    def gcd(numbers):
        """ Return the greatest common divisor of the given integers
        Euclidean algorithm """
        def gcd(a, b):
            if b == 0:
                return a
            else:
                return gcd(b, a % b)

        return reduce(gcd, numbers)

    def lcm(numbers):
        """ Return lowest common multiple."""
        def lcm(a, b):
            return (a * b) // gcd((a, b))

        return reduce(lcm, numbers)

    return lcm(list(factors))


def p6():
    """ Sum square difference
    The sum of the squares of the first ten natural numbers is,
    1²+ 2²+ ... + 10²= 385
    The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)² = 552 = 3025
    Hence the difference between the sum of the squares of the first
    ten natural numbers and the square of the sum is 3025 − 385 = 2640.
    Find the difference between the sum of the squares of the first
    one hundred natural numbers and the square of the sum.
    """
    sum_of_squares = sum([x**2 for x in range(101)])
    square_of_sum = sum(range(101)) ** 2
    return square_of_sum - sum_of_squares


def p7():
    """ 10001st prime
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10 001st prime number?
    """
    import sys
    sys.path.append("../idea bag/")
    from prime_factors import nth_prime

    return nth_prime(10001)


def p8():
    """ The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
    Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
    What is the value of this product?
    """
    from functools import reduce

    long_number = ("73167176531330624919225119674426574742355349194934"
                   + "96983520312774506326239578318016984801869478851843"
                   + "85861560789112949495459501737958331952853208805511"
                   + "12540698747158523863050715693290963295227443043557"
                   + "66896648950445244523161731856403098711121722383113"
                   + "62229893423380308135336276614282806444486645238749"
                   + "30358907296290491560440772390713810515859307960866"
                   + "70172427121883998797908792274921901699720888093776"
                   + "65727333001053367881220235421809751254540594752243"
                   + "52584907711670556013604839586446706324415722155397"
                   + "53697817977846174064955149290862569321978468622482"
                   + "83972241375657056057490261407972968652414535100474"
                   + "82166370484403199890008895243450658541227588666881"
                   + "16427171479924442928230863465674813919123162824586"
                   + "17866458359124566529476545682848912883142607690042"
                   + "24219022671055626321111109370544217506941658960408"
                   + "07198403850962455444362981230987879927244284909188"
                   + "84580156166097919133875499200524063689912560717606"
                   + "05886116467109405077541002256983155200055935729725"
                   + "71636269561882670428252483600823257530420752963450")
    assert(len(long_number) == 1000)
    adjacent = 13
    maximum = 0
    for index in range(1000 - adjacent):
        digits = long_number[index:index + 13]
        product = reduce(lambda x, y: x * y, map(lambda x: int(x), digits))
        maximum = product if product > maximum else maximum
    return maximum


def p9():
    """ Special Pythagorean triplet
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
    a² + b² = c²
    For example, 3² + 4² = 9 + 16 = 25 = 5².
    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    """
    for a in range(1, 500):
        for b in range(a, 500):
            c = sqrt(a**2 + b**2)
            if (a + b + c) == 1000:
                return a * b * int(c), "{}² + {}² = {}²".format(a, b, int(c))


def p10():
    """ Summation of primes
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    Find the sum of all the primes below two million.
    """
    import sys
    sys.path.append("../idea bag/")
    from prime_factors import sieve_of_eratosthenes
    primes = sieve_of_eratosthenes(2000000)
    res = sum(primes)
    assert(res == 142913828922)
    return res
    # VERY FUCKING SLOW (160s!!)
    # NOT ANY FUCKING MORE (5s!)
    # EVEN SLOWER with eratosthenes algorithm


if __name__ == '__main__':


    # func = p4

    # ts = time()
    # print(func())
    # # [func() for _ in range(10000)]
    # te = time()
    # print("{}(): {} s\n".format(func.__name__, (te - ts)))


    functions = (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)

    for func in functions:
        ts = time()
        print(func())
        te = time()
        print("{}(): {} s\n".format(func.__name__, (te - ts)))
